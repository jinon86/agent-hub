# WebMCP (Chrome early preview) 분석 메모

원문: https://venturebeat.com/infrastructure/google-chrome-ships-webmcp-in-early-preview-turning-every-website-into-a

## 한 줄 요약
WebMCP는 브라우저(Chrome) 안에서 웹사이트가 **에이전트용 “구조화된 도구(tool)” 인터페이스**를 노출하도록 하는 제안 표준으로, 기존의 취약한 스크래핑/클릭 자동화를 **단일 tool call + JSON 결과** 중심으로 바꾸려는 시도다.

---

## 배경: 왜 필요한가
현재 웹 에이전트(브라우저 에이전트)는 대부분 아래 두 방식 중 하나로 동작한다.

1) **비전 기반(스크린샷 + 멀티모달)**
- 이미지 입력은 토큰을 많이 소모하고 지연이 크다.
- UI 요소 인식/좌표 추정이 실패하면 흐름이 깨지기 쉽다.

2) **DOM 기반(HTML 파싱/추론)**
- HTML/CSS/JS는 사람 UI를 위한 언어라 에이전트에게 노이즈가 크다.
- 작은 UI 변경에도 자동화가 깨지기 쉽고, 컨텍스트 낭비가 크다.

결과적으로, 사람이 몇 초에 끝내는 검색/필터 작업도 에이전트는 여러 단계 클릭/스크롤/파싱을 거치며 다수의 추론 호출을 유발한다.

---

## WebMCP 핵심 아이디어
### 웹사이트가 “툴 계약(tool contract)”을 직접 노출
- 웹페이지가 지원하는 기능을 “이름/설명/파라미터 스키마/리턴 타입”으로 공개
- 에이전트는 화면 조작 대신 **구조화된 tool call**을 호출

기사에서 언급된 브라우저 API는 `navigator.modelContext`.

---

## 동작 방식: 2가지 API
### 1) Declarative API (선언형)
- 기존 HTML form에 tool name/description 등을 추가하는 방식
- 폼이 이미 정돈되어 있으면 구현 비용이 낮음

### 2) Imperative API (명령형)
- JS에서 `registerTool()` 같은 방식으로 동적/복잡 상호작용을 노출
- 예: `searchProducts(query, filters)` 같은 함수를 스키마 포함해 등록
- 에이전트는 1회 호출로 JSON 결과를 받고, 다단계 UI 조작을 줄일 수 있음

핵심 주장: “툴 1회 호출이 수십 번의 browser-use 인터랙션을 대체한다.”

---

## Human-in-the-loop 강조 (운영적으로 중요한 포인트)
WebMCP는 ‘완전 자율/헤드리스 자동화’가 아니라, **사용자가 브라우저에 присутств하는 협업형(workflow)**을 주요 목표로 둔다.

기사에서 언급된 3요소:
- Context: 사용자가 하는 일을 이해하기 위한 데이터
- Capabilities: 에이전트가 수행할 수 있는 행동
- Coordination: 에이전트가 해결 못할 때 사용자에게 핸드오프

즉, 사용자가 보는 브라우저 세션/맥락에서 에이전트가 도구 호출로 “보조”하는 모델에 가깝다.

---

## MCP(Anthropic MCP)와의 관계
- **MCP**: 백엔드에서 에이전트↔서비스를 연결하는 프로토콜(주로 서버-클라이언트, JSON-RPC 계열)
- **WebMCP**: 브라우저(클라이언트) 안에서 웹페이지가 도구를 노출

대체 관계가 아니라 보완 관계로 볼 수 있다.
- 서비스-서비스 자동화(브라우저 불필요): MCP가 적합
- 사용자 세션/화면 공유가 중요한 소비자 웹 플로우: WebMCP가 적합

---

## 기대효과
- **비용 절감**: 클릭/스크린샷/파싱 반복을 단일 tool call로 대체 → 토큰/호출 감소
- **신뢰성 향상**: UI 변경에 덜 취약(툴 계약 기반)
- **개발 속도**: 프론트엔드 JS 로직을 재활용해 도구 노출(백엔드 MCP 서버 별도 구축 비용 감소 가능)

---

## 리스크/불확실성
- **표준/호환성**: Chrome Canary 146, 플래그 기반(EPP). 타 브라우저 채택은 미정
- **생태계 채택**: “사이트가 도구를 노출해야” 효과가 큼. 도입 초기엔 한정적
- **보안/권한 모델**: 브라우저 세션 권한으로 강력한 조작이 가능해질수록 프롬프트 인젝션/오용 방지 설계가 중요

---

## 우리 운영(OpenClaw + Discord + GitHub Issue) 관점 메모
- 주 업무가 ‘백그라운드 자동화’(코드/문서/리포트)라면 WebMCP가 즉시 필요한 건 아님.
- 다만, **웹 콘솔/어드민/대시보드/리서치 사이트**처럼 브라우저 상호작용이 핵심인 업무가 많아지면,
  - 기존의 fragile한 브라우저 자동화 대신
  - “도구 계약 기반” 접근이 비용/안정성을 크게 개선할 가능성이 있다.

---

## 후속 액션(옵션)
- WebMCP spec/Chrome EPP 문서 확인 후, 적용 가능한 내부/외부 웹앱 목록 작성
- 브라우저 협업형 업무(구매/예약/폼 입력 등)에서 tool contract로 노출 가능한 액션 후보 추출
- 보안 가이드(세션/권한/승인/감사 로그) 초안 작성
